$$\mathcal L [u] = f$$
有限元的基本思想是将求解域分割成（不一定规则的）单元区域。这些区域的顶点为节点。然后以每个节点为中心将$u$分解为基函数，以此来逼近真实解：
$$u \approx u_h = \sum_{j=1}^N c_j N_j(x)$$
其中，$u_h$必须满足一下要求：
1. $u_h$在单元分界处必须是连续的
2. $N_j(x)$在节点$j$处取值为1，取值随与$j$的距离逐渐降低，在所有相邻的节点处降至0。
3. $N_j(x)$与它的一阶导必须在求解范围内必须是平方可积的
也就是说，$N_j(x)$在以节点$j$作为顶点的单元内取值为(0,1)，在所有其他单元内取值为0。$c$为基函数的系数，如果找到恰当的所有基函数的系数，$u_h$可以近似为$u$，从而获得方程的解。

所以此时待求解的方程变为：
$$\mathcal L \left[\sum_{j=1}^N c_j N_j\right] = f$$
但是算子$\mathcal L$至少包含一阶求导。对于线性分段函数$u_h$，函数段内的求导结果为常数，且函数分段的分界处无法求导，所以此方程无法成立。为了解决这个问题，我们可以放宽对解的限制：$u$不必在求解域中的每一点使等式成立（弱式），而是令其平均值在求解域中的每一小片区域等于使等式成立的平均值。也就是，我们假设只需让方程两边满足有限个足够多的泛函，就可认为等式成立：
$$F_j\left[ \mathcal L [u_h] \right] = F_j[f] \implies \mathcal L [u_h]  = f$$

其中我们可以令$F_j[g] = \int_{\Delta \Omega} \phi_j(x) g(x) \,d\Omega$，其中$\phi_j$为可以任意选择的测试函数。此时，等式变为：
$$\int \phi_j(x)\mathcal L[u_h(x)]\,dx= \int \phi_j(x) f(x)\,dx$$
选择测试函数的方法有很多，其中一种最常用的方法令测试函数等于基函数，且测试函数的数量等于基函数的数量。
$$\int N_i(x) \mathcal L\left[\sum_{j=1}^N c_j N_j(x) \right]\,dx= \int N_i(x) f(x)\,dx,\;\;\;\;\;\forall i=1,\dots,N$$
这种方法是伽辽金法，其优点是我们很容易一个二阶导数系统通过分部积分转化为一个一阶系统。在之后的示例中我们会进行演示。

通过交换求和求积的符号，我们可以将这个微分方程系统转化为一个矩阵系统：
$$\sum_{j=1}^N  \left(\int N_i(x) \mathcal L\left[ N_j(x) \right]\,dx \right) c_j = \int N_i(x) f(x)\,dx,\;\;\;\;\;\forall i=1,\dots,N$$
$$\sum_{j=1}^N P_{ij} c_j = b_i$$
其中：
$$P_{ij}=\int N_i(x) \mathcal L\left[ N_j(x) \right]\,dx$$
$$b_i = \int N_i(x) f(x)\,dx$$
可以通过分段求积分得到矩阵$P$与向量$b$的数值，然后通过求解线性方程组得到基函数的系数向量$c$，从而得到原方程的数值解。
值得注意的是，只在相邻节点的基函数的内积不为0，所以矩阵的元素$P_{ij}$在大部分的情况下为0，除非$i$与$j$为相邻节点。这样一来，矩阵$P$是一个稀疏矩阵。这会极大的降低计算成本。

一维泊松方程示例：
$$\frac{d^2u(x)}{dx} = f(x)$$
将等号两边乘以$\phi_i(x)$并积分：
$$\int \phi_i(x) \frac{d^2 u}{dx^2}\,dx= \int \phi_i(x)f(x) \,dx   $$
将$u$展开为基函数，并令$\phi_i(x)$等于基函数：
$$\int N_i(x) \frac{d^2}{dx^2} \left(\sum_{j=1}^N c_j N_j(x) \right)\,dx= \int N_i(x)f(x) \,dx   $$
交换求和求积符号：
$$\sum_{j=1}^N c_j\int N_i \frac{d^2}{dx^2}  N_j\,dx= \int N_i(x)f(x) \,dx   $$
使用分部积分，得到：
$$\sum_{j=1}^N c_j \left(N_i\frac{dN_j}{dx}\Big|_{x_0}^{x_1}   - \int\frac{dN_i}{dx}\frac{dN_j}{dx}dx\right) = \int N_i(x)f(x) \,dx   $$

### 边界条件
根据给出的边界条件，我们需要对矩阵$K$和向量$b$的前两个和最后两个元素进行修改。对于不同种类的边界条件，修改的方式有所不同。

##### 狄利克雷边界
此时给到了待求解函数的边界上的值：$u(0)=\gamma_0$, $u(l)=\gamma_l$。因为此时已知边界上的值，所以待求解的矩阵系统可以减少两个元素：第一行与最后一行，第一列与最后一列
$$K'=K_{[1:-1,1:-1]}$$
$$b' = b_{[1:-1]}$$
与此同时，固定的边界条件限制了被边界影响的单元，也就是$K$中第一列与最后一列不为0的单元（这个问题中是第二个与倒数第二个单元）。我们需要对这两个单元根据最初的的矩阵关系和边界条件进行修改：
$$K'[0]:=K'[0]-K[1,0]\gamma_0$$
$$K'[-1]:=K'[-1]-K[-2,-1]\gamma_0$$
待求解的矩阵系统变成了：
$$K'c=b'$$

##### 诺依曼边界
此时给到了待求解函数的边界上导数的值：$u'(0)=\gamma_0$, $u'(l)=\gamma_l$。此时我们需要对边界上的单元加以限制：
$$b'[0]=b[0]-\gamma_0$$
$$b'[-1]=b[-1]-\gamma_0$$


### 二维及以上的有限元法

在组装矩阵系统时，需要注意的一点是$K$的非零元素不一定在对角线及其上下。因为一个单元对应的节点不一定拥有相邻的索引数。比如，一个单元拥有节点$a,b,c$，那么这个单元只会在$k_{i,j}$对于$i,j\in\{a,b,c\}$ 任意排列的地方贡献非零值。




## 时域vs频域
麦克斯韦方程组在时域中的表达式为
$$\nabla \cdot \bf E = \frac{\rho}{\epsilon_0}$$
$$ \nabla \cdot \bf B = 0 $$
$$\nabla \times \bf E = -\frac{\partial \bf B}{\partial t}$$
$$\nabla \times \bf B = \mu_0 \bf J + \frac{1}{c^2}\frac{\partial \bf E}{\partial t}$$
使用对于时间变量$t$的傅立叶变换后，等式变为
$$\nabla \times \mathbf{E} = -\mathrm j \omega \mathbf{B}$$
$$\nabla \times \mathbf B = \mu_0 \mathbf J + \frac{\mathrm j \omega}{c^2} \mathbf E$$
可以看到麦克斯韦方程组在时域拥有四个自变量，而将其变换至频域可以消除时间依赖性，变成一个三维问题。在计算电磁学的大部分应用中，计算是频域中计算完成的。




# 基于有限元的变种方法

## 时域问题
如果待求解的微分方程组有时间变量，则未知解的基函数展开系数不再是常数，而是一个关于时间的方程。此外，待求解方程的弱形式包含关于时间的导数。虽然时间变量可以像空间变量一样被离散成有限单元，但是这种方法会大幅增加计算成本。因此，我们可以使用对于时间的有限分差或者RK方法，对每一个时间步依次求解，这样就可以将有时间变量的方程组还原成没有时间变量的形式。


## 间断伽辽金法
之前介绍的方法可以被称为连续伽辽金法，因为它是根据原微分方程的弱式进行求解。间断伽辽金法对求解域中的每一个单元分别生成一个弱式，构造一个小矩阵系统，而不是构造一个大矩阵系统。因此，利用间断伽辽金法，我们可以求解特定的一片区域，而无需求解整个系统。同时，单元之间的独立性使得此方法非常适合并行计算。

类似于连续伽辽金法，对微分方程的两边乘上一个测试函数，但此时仅在单元$e$内积分：
$$\int_{x_1^e}^{x_2^e} v^e\mathcal L [u] \,dx= \int_{x_1^e}^{x_2^e} v^ef \,dx$$
对于单元$e$，我们使用基函数将其展开：
$$u_h(x) = \sum_{l=1}^P c_e^l \phi^l(x),\;\;\;\; x\in 单元e$$
其中$\phi^l$为级数为$l$的多项式。然后得到仅对单元$e$的矩阵系统：
$$A_ec_e=b_e$$
其中$A_e$可以表示为$\phi$与$\frac{d\phi}{dx}$，以及边界条件的显式。$b_e$可以表示为相邻单元外侧所共享的边值解。对于一个边值问题，我们可以先使用给到的边值条件构造出矩阵系统，来解出与边界相邻的单元。然后通过解出的单元构造出与之相邻的其他单元，以此传递下去可以解出整个求解域。



## 自适应有限元 
在一般的有限元方法中，网格已在计算之前划分完成。在自适应方法中，计算之前划分的网格非常粗糙，但是网格会在每次计算之后根据事后误差估计进行细化，此过程可能重复多次：
1. 建立初始的粗糙网格划分$\mathcal T_k$ ,$k=0$
2. 在$\mathcal T_k$ 上，使用有限元方法求得数值解$U_k$
3. 对于每一个单元$K\in\mathcal T_k$，计算误差指示器$\eta_K$.
4. 如果全局误差指示器$\eta$小于一个阈值，停止计算并得到网格划分的结果
5. 否则，如果$\eta_K$大于一个阈值，则将$K$细化。（可选：如果一个$\eta_K$或者相邻的多个单元格之和小于另一阈值，则将这些单元格逆细化。）进入下一次迭代。


细化主要分为三种类型：
1. h细化：$h$为单元格度量空间直径。将一个单元格分割成多个子单元格使得每一个单元格的$h$减小。通过减少$h$来细化网格划分。
2. p细化：$p$为单元格插值多项式的阶数。通过提升$p$来细化网格划分。
3. h-p细化：以上两种类型的结合。


在实际问题中，网格在自适应完成后，最大网格的直径可以比最小网格的直径长多个数量级。因此，自适应有限元可以非常有效地在每个求解部分配计算成本，以此最优地平衡精度与计算量。